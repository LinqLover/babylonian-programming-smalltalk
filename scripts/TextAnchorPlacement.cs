'From Squeak5.3alpha of 22 July 2019 [latest update: #18680] on 23 July 2019 at 5:53:53 pm'!CharacterScanner subclass: #CharacterBlockScanner	instanceVariableNames: 'characterPoint characterIndex nextLeftMargin specialWidth lastCharacterWidth '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Text'!!CharacterBlockScanner commentStamp: 'pre 5/27/2019 17:56' prior: 0!A CharacterScanner does scan text to compute the CharacterBlock for a character specified by its index in the text or its proximity to the cursor location. The CharacterBlock stores information both about character layout and character index in the text.This class is essential for selecting text with the mouse or with arrow keys.Instance Variables	characterIndex:		<Integer | nil>	characterPoint:		<Point>	lastCharacterWidth:		<Number | nil>	nextLeftMargin:		<Number>characterIndex	- the index of character for which the layout information is searched, or nil when the layout is searched by cursor locationcharacterPoint	- the cursor location for which nearest character index and layout are searched.lastCharacterWidth	- a number indicating the width of last character being processed.	Note that this variable is left to nil during the inner scan loop, and only set on stopConditions.nextLeftMargin	- a number specifying the distance between left of composition zone and left of first character for the next line.!!Text commentStamp: 'pre 6/24/2019 13:12' prior: 0!I represent a character string that has been marked with abstract changes in character appearance. Actual display is performed in the presence of a TextStyle which indicates, for each abstract code, an actual font to be used.  A Text associates a set of TextAttributes with each character in its character string.  These attributes may be font numbers, emphases such as bold or italic, or hyperling actions.  Font numbers are interpreted relative to whatever textStyle appears, along with the text, in a Paragraph.  Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.  Each of my instances has	string		a String	runs		a RunArray!Object subclass: #TextAnchorProperties	instanceVariableNames: 'padding verticalAlignmentLine verticalAlignmentMorph consumesHorizontalSpace relativePosition anchorLayout positionInDocument morphBaselineGetter'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextAnchorProperties commentStamp: 'pre 6/27/2019 18:29' prior: 0!A TextAnchorProperties describes the positioning of a morph in a text document included through a TextAnchor. The properties describe:- general alignment of the morph (e.g. within the line or relative to the document)- vertical alignment within a line- padding applied in addition to the vertical alignment- whether it consumes horizontal space when layouted inline!TestCase subclass: #TextAnchorTest	instanceVariableNames: 'anchoredMorph text anchorAttribute textMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'MorphicTests-Text Support'!Morph subclass: #TextAnchorTestMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MorphicTests-Text Support'!!Character class methodsFor: 'accessing untypeable characters' stamp: 'pre 5/28/2019 18:16'!startOfHeader	^ self value: 1 ! !!Character class methodsFor: 'instance creation' stamp: 'pre 6/28/2019 10:37'!separators	"Answer a collection of space-like separator characters.	Note that we do not consider spaces in >8bit code points yet.	"	^ #(1 "start of header"		9 "tab"		10 "line feed"		12 "form feed"		13 "cr"		32 "space"		160 "non-breaking space, see Unicode Z general category")		collect: [:v | Character value: v] as: String" To be considered:16r1680 OGHAM SPACE MARK16r2000 EN QUAD16r2001 EM QUAD16r2002 EN SPACE16r2003 EM SPACE16r2004 THREE-PER-EM SPACE16r2005 FOUR-PER-EM SPACE16r2006 SIX-PER-EM SPACE16r2007 FIGURE SPACE16r2008 PUNCTUATION SPACE16r2009 THIN SPACE16r200A HAIR SPACE16r2028 LINE SEPARATOR16r2029 PARAGRAPH SEPARATOR16r202F NARROW NO-BREAK SPACE16r205F MEDIUM MATHEMATICAL SPACE16r3000 IDEOGRAPHIC SPACE"! !!CharacterScanner methodsFor: 'private-text-anchor' stamp: 'pre 6/13/2019 13:19'!textAnchorPropertiesFor: aMorphOrForm	^ aMorphOrForm isForm		ifTrue: [TextAnchorProperties new]		ifFalse: [aMorphOrForm textAnchorProperties]! !!CharacterScanner methodsFor: 'private' stamp: 'pre 5/27/2019 17:53'!placeEmbeddedObjectFrom: aTextAttribute	"Place the anchoredMorph or return false if it cannot be placed"	^ true! !!CharacterScanner methodsFor: 'stop conditions' stamp: 'pre 6/4/2019 17:04'!embeddedObject	pendingKernX := 0.	((text attributesAt: lastIndex) reject: [:each | each anchoredMorph isNil])		ifNotEmpty: [:attributes | attributes do: [:attr |			"Try to placeEmbeddedObject: - if it answers false, then there's no place left"			(self placeEmbeddedObjectFrom: attr) ifFalse: [^ self crossedX]]]. 	"Note: if ever several objects are embedded on same character, only indent lastIndex once"	lastIndex := lastIndex + 1.	^false! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'pre 5/27/2019 17:51'!setFont	super setFont! !!CharacterBlockScanner methodsFor: 'private' stamp: 'pre 6/13/2019 21:30'!placeEmbeddedObjectFrom: aTextAttribute		| width anchoredMorphOrForm textAnchorProperties |	anchoredMorphOrForm := aTextAttribute anchoredMorph.	textAnchorProperties := self textAnchorPropertiesFor: anchoredMorphOrForm.		textAnchorProperties anchorLayout == #document ifTrue: [^ true].	width := textAnchorProperties consumesHorizontalSpace 		ifTrue: [anchoredMorphOrForm width + textAnchorProperties horizontalPadding]		ifFalse: [0].		lastCharacterWidth := width.			(destX + width > characterPoint x) ifTrue: [^false].	destX := destX + width + kern.	^ true! !!CharacterBlockScanner methodsFor: 'private' stamp: 'pre 5/27/2019 17:50'!retrieveLastCharacterWidth	| lastCharacter |	lastIndex > text size ifTrue: [^lastCharacterWidth := 0].	lastCharacter := text at: lastIndex.	(lastCharacter charCode >= 256 or: [(stopConditions at: lastCharacter charCode + 1) isNil])		ifTrue: [lastCharacterWidth := font widthOf: (text at: lastIndex)].	"if last character was a stop condition, then the width is already set"	^lastCharacterWidth! !!CompositionScanner methodsFor: 'private' stamp: 'pre 6/27/2019 18:15'!alignmentMorphOffsetFor: textAnchorProperties of: aMorphOrForm	^ textAnchorProperties verticalAlignmentMorph caseOf: {				[#top] -> [textAnchorProperties padding top].				[#center] -> [(aMorphOrForm height / 2) floor].				[#baseline] -> [textAnchorProperties morphBaselineGetter					ifNil: [0]					ifNotNil: [:s | aMorphOrForm perform: s]].				[#bottom] -> [aMorphOrForm height + textAnchorProperties padding bottom]}! !!CompositionScanner methodsFor: 'private' stamp: 'pre 6/27/2019 18:15'!baselineAdjustmentFor: textAnchorProperties	^ textAnchorProperties verticalAlignmentLine caseOf: {				[#top] -> [font ascent].				[#center] -> [(font ascent / 2) floor].				[#baseline] -> [0].				[#bottom] -> [font descent negated]}.				! !!CompositionScanner methodsFor: 'private' stamp: 'pre 6/11/2019 15:22'!lineHeightForMorphOfHeight: aMorphHeight aligned: morphPosition to: linePosition 		^ self		lineHeightForMorphOfHeight: aMorphHeight		aligned: morphPosition 		to: linePosition		paddedWith: 0		andOptionalMorphBaseline: 0! !!CompositionScanner methodsFor: 'private' stamp: 'pre 6/27/2019 18:17'!lineHeightForMorphOfHeight: aMorphHeight aligned: morphPosition to: linePosition paddedWith: verticalPadding andOptionalMorphBaseline: morphBaseline	"The idea here is to first compute the total height and then subtract the overlapping area."	| adjustedLineHeight morphHeight total |	morphHeight := aMorphHeight + verticalPadding.	total := font height + morphHeight.	adjustedLineHeight := 0.		morphPosition = #top 		ifTrue: [			linePosition = #top			ifTrue: [adjustedLineHeight := total - font height].			linePosition = #center 		ifTrue: [adjustedLineHeight := total - (font descent + (font ascent / 2))].			linePosition = #baseline 	ifTrue: [adjustedLineHeight := total - font descent].			linePosition = #bottom 		ifTrue: [adjustedLineHeight := total].].	morphPosition = #center 	ifTrue: [ | upperMorphHalf lowerMorphHalf |			"The overlapping area of a morph aligned at the center position can be determined by splitting 			the morph into a top half which is aligned at the bottom and a lower half aligned at the top."			upperMorphHalf := self 				lineHeightForMorphOfHeight: aMorphHeight / 2 				aligned: #bottom to: linePosition. 			lowerMorphHalf := self 				lineHeightForMorphOfHeight: aMorphHeight / 2 				aligned: #top to: linePosition.			adjustedLineHeight := upperMorphHalf + lowerMorphHalf - font height].	morphPosition = #baseline ifTrue: [ | upperMorphHalf lowerMorphHalf |			"We use the same trick as we used with the center position but with different proportions of the morph."			upperMorphHalf := self 				lineHeightForMorphOfHeight: morphBaseline 				aligned: #bottom to: linePosition. 			lowerMorphHalf := self 				lineHeightForMorphOfHeight: aMorphHeight - morphBaseline 				aligned: #top to: linePosition.			adjustedLineHeight := upperMorphHalf + lowerMorphHalf - font height].	morphPosition = #bottom 	ifTrue: [			linePosition = #top			ifTrue: [adjustedLineHeight := total].			linePosition = #center 		ifTrue: [adjustedLineHeight := total - (font ascent / 2)].			linePosition = #baseline 	ifTrue: [adjustedLineHeight := total - font ascent].			linePosition = #bottom 		ifTrue: [adjustedLineHeight := total - font height].].	^ lineHeight max: adjustedLineHeight	! !!CompositionScanner methodsFor: 'private' stamp: 'pre 6/14/2019 20:17'!placeEmbeddedObjectFrom: aTextAttribute	| width anchoredMorphOrForm textAnchorProperties |	anchoredMorphOrForm := aTextAttribute anchoredMorph.	textAnchorProperties := self textAnchorPropertiesFor: anchoredMorphOrForm.		textAnchorProperties anchorLayout == #document ifTrue: [^ true].	"If it is not anchored at the document, we assume that it is inline."	width := anchoredMorphOrForm width + textAnchorProperties horizontalPadding.	(destX + width > rightMargin and: [(leftMargin + width) <= rightMargin or: [lastIndex > line first]])		ifTrue: ["Won't fit, but would on next line"				^ false].		"The width had to be set beforehand to determine line wrapping. 	We can now re-use and reset it as it might not be necessary anymore. --pre"	width := textAnchorProperties consumesHorizontalSpace 		ifTrue: [anchoredMorphOrForm width + textAnchorProperties horizontalPadding]		ifFalse: [0].	destX := destX + width + kern.		baseline := baseline max: 		(self alignmentMorphOffsetFor: textAnchorProperties of: anchoredMorphOrForm) 			+ (self baselineAdjustmentFor: textAnchorProperties).	lineHeight := self 		lineHeightForMorphOfHeight: anchoredMorphOrForm height		aligned: textAnchorProperties verticalAlignmentMorph 		to: textAnchorProperties verticalAlignmentLine		paddedWith: textAnchorProperties verticalPadding		andOptionalMorphBaseline: (textAnchorProperties morphBaselineGetter 			ifNotNil: [:getter | anchoredMorphOrForm perform: getter] ifNil: [0]).	^ true! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'pre 5/24/2019 16:10'!embeddedObject	"TODO: document the reason for this decrement --pre"	lastDisplayableIndex := lastIndex - 1.	^ super embeddedObject! !!DisplayScanner methodsFor: 'private' stamp: 'pre 6/13/2019 21:29'!embeddedObject: anchoredMorphOrForm shouldBePlacedInDocumentGiven: textAnchorProperties		^ textAnchorProperties hasPositionInDocument 		and: [textAnchorProperties anchorLayout == #document] 		and: [anchoredMorphOrForm isMorph]! !!DisplayScanner methodsFor: 'private' stamp: 'pre 6/14/2019 20:11'!placeEmbeddedObject: anchoredMorphOrForm inlineGiven: textAnchorProperties		| alignedPositionY position |	alignedPositionY := self verticallyAlignEmbeddedObject: anchoredMorphOrForm given: textAnchorProperties.	position := ((destX + textAnchorProperties padding left) @ alignedPositionY) - morphicOffset.	anchoredMorphOrForm isMorph		ifTrue: [	anchoredMorphOrForm position: position]		ifFalse: ["we assume this to be a form" 			self displayEmbeddedForm: anchoredMorphOrForm at: position].	! !!DisplayScanner methodsFor: 'private' stamp: 'pre 6/13/2019 21:29'!placeEmbeddedObjectFrom: aTextAttribute		| width anchoredMorphOrForm textAnchorProperties |	anchoredMorphOrForm := aTextAttribute anchoredMorph.	textAnchorProperties := self textAnchorPropertiesFor: anchoredMorphOrForm.		(self embeddedObject: anchoredMorphOrForm shouldBePlacedInDocumentGiven: textAnchorProperties) 			ifTrue: [^ self placeEmbeddedObjectInDocument: anchoredMorphOrForm].	 .self placeEmbeddedObject: anchoredMorphOrForm inlineGiven: textAnchorProperties.		width := textAnchorProperties consumesHorizontalSpace 				ifTrue: [anchoredMorphOrForm width + textAnchorProperties horizontalPadding]				ifFalse: [0].	destX := destX + width + kern.		^ true! !!DisplayScanner methodsFor: 'private' stamp: 'pre 6/13/2019 21:25'!placeEmbeddedObjectInDocument: anchoredMorphOrForm		anchoredMorphOrForm position: 			anchoredMorphOrForm textAnchorProperties positionInDocument +			(anchoredMorphOrForm owner textBounds origin x @ (lineY - morphicOffset y)).	^ true! !!DisplayScanner methodsFor: 'private' stamp: 'pre 6/27/2019 18:16'!verticallyAlignEmbeddedObject: aMorphOrForm given: textAnchorProperties	| alignedPositionY positionInLine morphPosition padding morphBaselineGetter |	alignedPositionY := lineY + line baseline.	positionInLine := textAnchorProperties verticalAlignmentLine.	positionInLine = #top 		ifTrue: 	[alignedPositionY := alignedPositionY - font ascent].	positionInLine = #center 	ifTrue: 	[alignedPositionY := (alignedPositionY - (font ascent / 2)) floor].	positionInLine = #bottom	ifTrue: 	[alignedPositionY := alignedPositionY + font descent].	"#baseline does not require adjustments"		padding := textAnchorProperties padding.	morphBaselineGetter := textAnchorProperties morphBaselineGetter.	morphPosition := textAnchorProperties verticalAlignmentMorph.	morphPosition = #top		ifTrue: [alignedPositionY := alignedPositionY + padding top. Transcript showln: padding top].	morphPosition = #center 	ifTrue: [alignedPositionY := (alignedPositionY - (aMorphOrForm height / 2)) floor].	morphPosition = #baseline	ifTrue: [alignedPositionY := alignedPositionY - (morphBaselineGetter ifNotNil: [:getter | aMorphOrForm perform: getter] ifNil: [0])].	morphPosition = #bottom 	ifTrue: [alignedPositionY := (alignedPositionY - aMorphOrForm height) - padding bottom].	"We only apply padding to the position the morph is aligned to."			^ alignedPositionY! !!DisplayScanner methodsFor: 'displaying' stamp: 'pre 5/24/2019 16:03'!displayEmbeddedForm: aForm at: aPoint	self subclassResponsibility! !!BitBltDisplayScanner methodsFor: 'displaying' stamp: 'pre 6/5/2019 11:35'!displayEmbeddedForm: aForm at: aPoint	aForm 		displayOn: bitBlt destForm 		at: aPoint + (aForm extent / 2)		clippingBox: bitBlt clipRect		rule: Form blend		fillColor: Color white ! !!Form methodsFor: 'other' stamp: 'RAA 1/30/2002 16:42'!relativeTextAnchorPosition	^nil		"so forms can be in TextAnchors"! !!Morph methodsFor: 'text-anchor' stamp: 'pre 6/14/2019 19:14'!addTextAnchorMenuItems: topMenu hand: aHand	^ self textAnchorProperties 		addTextAnchorMenuItems: topMenu 		hand: aHand		for: self! !!Morph methodsFor: 'text-anchor' stamp: 'pre 6/5/2019 15:11'!textAnchorProperties	^ self valueOfProperty: #textAnchorProperties ifAbsentPut: [TextAnchorProperties new]! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/11/2019 15:52'!changeDocumentAnchor	"Change the anchor from/to document anchoring"	| newType |	newType := self textAnchorProperties anchorLayout == #document 		ifTrue: [#inline]		ifFalse: [ #document].	self textAnchorProperties anchorLayout: newType.	owner isTextMorph ifTrue: [		owner 			anchorMorph: self			at: self position			type: newType]! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/11/2019 15:52'!changeInlineAnchor	"Change the anchor from/to line anchoring"	| newType |	newType := self textAnchorProperties anchorLayout == #inline 		ifTrue: [#document]		ifFalse: [#inline]. 	self textAnchorProperties anchorLayout: newType.	owner isTextMorph ifTrue: [		owner 			anchorMorph: self			at: self position			type: newType]! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/14/2019 19:06'!changeParagraphAnchor	"Change the anchor from/to paragraph anchoring"	| newType |	self deprecated: 'paragraph is not supported anymore'.	newType := self textAnchorProperties anchorLayout == #paragraph 		ifTrue: [#document]		ifFalse: [#paragraph].	owner isTextMorph ifTrue: [		owner 			anchorMorph: self			at: self position			type: newType]! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/4/2019 17:47'!hasDocumentAnchorString	^ (self textAnchorProperties anchorLayout == #document		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'Document' translated! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/4/2019 17:47'!hasInlineAnchorString	^ (self textAnchorProperties anchorLayout == #inline		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'Inline' translated! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/14/2019 19:06'!hasParagraphAnchorString	self deprecated: 'paragraph is not supported anymore'.	^ (self textAnchorProperties anchorLayout == #paragraph		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'Paragraph' translated! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/14/2019 19:05'!relativeTextAnchorPosition	self deprecated: 'Use textAnchorProperties instead'.	^self valueOfProperty: #relativeTextAnchorPosition! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/14/2019 19:05'!relativeTextAnchorPosition: aPoint	self deprecated: 'Use textAnchorProperties instead'.	^self setProperty: #relativeTextAnchorPosition toValue: aPoint! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/14/2019 19:05'!textAnchorType	self deprecated: 'Use textAnchorProperties instead'.	^self valueOfProperty: #textAnchorType ifAbsent:[#document]! !!Morph methodsFor: '*60Deprecated-text-anchor' stamp: 'pre 6/14/2019 19:05'!textAnchorType: aSymbol		self deprecated: 'Use textAnchorProperties instead'.	aSymbol == #document		ifTrue:[^self removeProperty: #textAnchorType]		ifFalse:[^self setProperty: #textAnchorType toValue: aSymbol].! !!TextAnchorProperties methodsFor: 'accessing - padding' stamp: 'pre 6/4/2019 17:29'!horizontalPadding	^ self padding left + self padding right! !!TextAnchorProperties methodsFor: 'accessing - padding' stamp: 'pre 6/4/2019 17:27'!padding	^ padding ifNil: [0@0 corner: 0@0]! !!TextAnchorProperties methodsFor: 'accessing - padding' stamp: 'pre 6/4/2019 17:27'!padding: numberOrPointOrRectangle	| newPadding |	newPadding := numberOrPointOrRectangle.	newPadding isPoint ifTrue: [		newPadding := newPadding corner: newPadding].	newPadding isNumber ifTrue: [		newPadding := newPadding@newPadding corner: newPadding@newPadding].	^ padding := newPadding! !!TextAnchorProperties methodsFor: 'accessing - padding' stamp: 'pre 6/13/2019 21:20'!verticalPadding	self verticalAlignmentMorph = #top 		ifTrue: [^ self padding top].	self verticalAlignmentMorph = #bottom 	ifTrue: [^ self padding bottom].	^ 0! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'pre 6/5/2019 16:09'!anchorLayout	"See anchorLayout:"	^ anchorLayout ifNil: [self defaultAnchorLayout]! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'pre 6/5/2019 16:09'!anchorLayout: aSymbolOrNil	"Anchor layout determines how the morph is embedded into the text.		document:	The morph is placed relative to the complete document. 	The relative position is in relation to the document topLeft.	inline: The moph is layouted inline. The position of the morph is 	determined through verticalAlignment and consumesHorizontalSpace."		self assert: (#(document inline nil) includes: aSymbolOrNil).	^ anchorLayout := aSymbolOrNil! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'pre 6/4/2019 17:37'!consumesHorizontalSpace	^ consumesHorizontalSpace ifNil: [true]! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'pre 6/4/2019 17:37'!consumesHorizontalSpace: aBoolean	^ consumesHorizontalSpace := aBoolean! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'pre 6/5/2019 15:22'!defaultAnchorLayout	^ #inline! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'pre 6/11/2019 15:14'!morphBaselineGetter	^ morphBaselineGetter! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'pre 6/27/2019 18:22'!morphBaselineGetter: aSymbol	"This sets the callback send to the anchored morph to determine the baseline	of the morph. The baseline should be the distance from the top of the anchored	morph. This can be used, e.g. when having formula morphs inside a text."	morphBaselineGetter := aSymbol! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'pre 6/5/2019 16:05'!positionInDocument	^ positionInDocument! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'pre 6/27/2019 18:29'!positionInDocument: aPoint	"See anchorLayout:"	 	^ positionInDocument := aPoint! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'cmm 6/27/2019 18:02'!verticalAlignment: symbolOrTuple	"This method accepts tuples in which the first element designates 	which part of the morph is aligned to which part of the text line which 	the second element designates.	morph baseline allows for the morph to set its own baseline (see morphBaselineGetter:)"	symbolOrTuple isSymbol		ifTrue:			[ self 				verticalAlignmentMorph: symbolOrTuple; 				verticalAlignmentLine: symbolOrTuple ]		ifFalse: 			[  self 				verticalAlignmentMorph: symbolOrTuple first ;				verticalAlignmentLine: symbolOrTuple second ]! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'cmm 6/27/2019 17:56'!verticalAlignmentLine	"The vertical position within the line of text where the anchor point of the morph, specified by #verticalAlignmentMorph, should be attached."	^ verticalAlignmentLine ifNil: [ #center ]! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'cmm 6/27/2019 17:55'!verticalAlignmentLine: aSymbol	"The vertical position within the line of text where the anchor point of the morph, specified by #verticalAlignmentMorph, should be attached."	self assertValidAlignment: aSymbol.	verticalAlignmentLine := aSymbol! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'cmm 6/27/2019 17:56'!verticalAlignmentMorph	"The vertical position of the embedded Morph where it anchors to a line of text, its position within that line specified by #verticalAlignmentLine.."	^ verticalAlignmentMorph ifNil: [ #center ]! !!TextAnchorProperties methodsFor: 'accessing' stamp: 'cmm 6/27/2019 17:55'!verticalAlignmentMorph: aSymbol	"The vertical position of the embedded Morph where it anchors to a line of text, its position within that line specified by #verticalAlignmentLine.."	self assertValidAlignment: aSymbol.	verticalAlignmentMorph := aSymbol! !!TextAnchorProperties methodsFor: 'default values' stamp: 'pre 6/27/2019 18:12'!defaultVerticalAlignment	^ #(center center)! !!TextAnchorProperties methodsFor: 'testing' stamp: 'pre 6/13/2019 21:22'!hasPositionInDocument	^ self positionInDocument notNil! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/27/2019 18:13'!addTextAnchorMenuItems: topMenu hand: aHand for: aMorph	| layoutTypeMenu anchorMenu morphAlignmentMenu lineAlignmentMenu |	layoutTypeMenu := MenuMorph new defaultTarget: self.	layoutTypeMenu 		addUpdating: #hasInlineAnchorString 		target: self		selector: #toggleInlineAnchorIn:		argumentList: {aMorph}.	layoutTypeMenu 		addUpdating: #hasDocumentAnchorString 		target: self		selector: #toggleDocumentAnchorIn:		argumentList: {aMorph}.			morphAlignmentMenu := MenuMorph new defaultTarget: self.	#(morphAlignmentIsBottomString #bottom 	morphAlignmentIsBaselineString #baseline 	morphAlignmentIsCenterString #center  	morphAlignmentIsTopString #top) pairsDo: [:labelGetter :alignment |		morphAlignmentMenu 			addUpdating: labelGetter 			target: self			selector: #changeMorphAlignmentFor:to:			argumentList: {aMorph . alignment}].		lineAlignmentMenu := MenuMorph new defaultTarget: self.	#(lineAlignmentIsBottomString #bottom 	lineAlignmentIsBaselineString #baseline 	lineAlignmentIsCenterString #center  	lineAlignmentIsTopString #top) pairsDo: [:labelGetter :alignment |		lineAlignmentMenu 			addUpdating: labelGetter 			target: self			selector: #changeLineAlignmentFor:to:			argumentList: {aMorph . alignment}].			anchorMenu := MenuMorph new defaultTarget: self.	anchorMenu add: 'layout type' translated subMenu: layoutTypeMenu.	anchorMenu add: 'morph vertical alignment' translated subMenu: morphAlignmentMenu.	anchorMenu add: 'line vertical alignment' translated subMenu: lineAlignmentMenu.			topMenu ifNotNil: [topMenu add: 'text anchor' translated subMenu: anchorMenu].	^ anchorMenu! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/28/2019 09:45'!changeLineAlignmentFor: aMorph to: aSymbol	self verticalAlignmentLine: aSymbol.	self updateOwnerOf: aMorph.! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/28/2019 09:45'!changeMorphAlignmentFor: aMorph to: aSymbol	self verticalAlignmentMorph: aSymbol.	self updateOwnerOf: aMorph.! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 19:55'!hasDocumentAnchorString	^ (self anchorLayout == #document			ifTrue: ['<on>']			ifFalse: ['<off>'])		, 'document' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 19:55'!hasInlineAnchorString	^ (self anchorLayout == #inline			ifTrue: ['<on>']			ifFalse: ['<off>'])		, 'inline' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 19:55'!lineAlignmentIsBaselineString	^ (self verticalAlignmentLine = #baseline 			ifTrue: ['<on>']			ifFalse: ['<off>']) 		, 'baseline' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 19:57'!lineAlignmentIsBottomString	^ (self verticalAlignmentLine = #bottom 			ifTrue: ['<on>']			ifFalse: ['<off>']) 		, 'bottom' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/27/2019 18:13'!lineAlignmentIsCenterString	^ (self verticalAlignmentLine = #center 			ifTrue: ['<on>']			ifFalse: ['<off>']) 		, 'center' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 19:57'!lineAlignmentIsTopString	^ (self verticalAlignmentLine = #top 			ifTrue: ['<on>']			ifFalse: ['<off>']) 		, 'top' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 19:56'!morphAlignmentIsBaselineString	^ (self verticalAlignmentMorph = #baseline 			ifTrue: ['<on>']			ifFalse: ['<off>']) 		, 'baseline' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 19:56'!morphAlignmentIsBottomString	^ (self verticalAlignmentMorph = #bottom 			ifTrue: ['<on>']			ifFalse: ['<off>']) 		, 'bottom' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/27/2019 18:13'!morphAlignmentIsCenterString	^ (self verticalAlignmentMorph = #center 			ifTrue: ['<on>']			ifFalse: ['<off>']) 		, 'center' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 19:56'!morphAlignmentIsTopString	^ (self verticalAlignmentMorph = #top 			ifTrue: ['<on>']			ifFalse: ['<off>']) 		, 'top' translated! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 20:00'!toggleDocumentAnchorIn: aMorph	"Change the anchor from/to document anchoring"	| newType |	newType := self anchorLayout == #document 		ifTrue: [#inline]		ifFalse: [ #document].	self anchorLayout: newType.	self updateOwnerOf: aMorph.	! !!TextAnchorProperties methodsFor: 'menu' stamp: 'pre 6/14/2019 20:00'!toggleInlineAnchorIn: aMorph	"Change the anchor from/to line anchoring"	| newType |	newType := self anchorLayout == #inline 		ifTrue: [#document]		ifFalse: [#inline]. 	self anchorLayout: newType.	self updateOwnerOf: aMorph.! !!TextAnchorProperties methodsFor: 'private' stamp: 'cmm 6/27/2019 17:54'!assertValidAlignment: aSymbol	^ #(top center baseline bottom) includes: aSymbol! !!TextAnchorProperties methodsFor: 'private' stamp: 'pre 6/14/2019 20:00'!updateOwnerOf: aMorph	aMorph owner isTextMorph ifTrue: [		aMorph owner 			anchorMorph: aMorph			at: aMorph position			type: self anchorLayout]	! !!TextAnchorTest methodsFor: 'running' stamp: 'pre 6/27/2019 18:19'!setUp	super setUp.	anchoredMorph := TextAnchorTestMorph new.	anchorAttribute := TextAnchor new anchoredMorph: anchoredMorph. 	text := Text streamContents: [:stream | 		stream			nextPutAll: 'Here is a contrived example ';			nextPutAll: (Text				string: Character startOfHeader asString				attributes: {					anchorAttribute. 					TextColor color: Color transparent});			nextPutAll: ' whose morph is in the center.' ].	self prepareTextMorph.! !!TextAnchorTest methodsFor: 'utility' stamp: 'pre 6/13/2019 20:49'!after: aBlock paddingChangesTo: assertBlock	anchoredMorph := TextAnchorTestMorph new.	anchorAttribute anchoredMorph: anchoredMorph.	aBlock value.	self prepareTextMorph.	assertBlock value: (textMorph paragraph lines first).	! !!TextAnchorTest methodsFor: 'utility' stamp: 'pre 6/5/2019 15:14'!prepareTextMorph	textMorph := text asMorph.	self refreshTextMorph.! !!TextAnchorTest methodsFor: 'utility' stamp: 'pre 6/12/2019 11:11'!refreshTextMorph	textMorph changed; imageForm. "This triggers a redraw and thereby positions the embedded morphs."! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/5/2019 15:20'!testBeginWithAnAnchor		text := Text streamContents: [:stream | 		stream 			nextPutAll: (Text				string: Character startOfHeader asString				attributes: {					anchorAttribute. 					TextColor color: Color transparent}) ;			nextPutAll: ' should be able to begin with an embedded object. '].	self prepareTextMorph.	self 		assert: (anchoredMorph ownerChain includes: textMorph);		assert: anchoredMorph topLeft >= textMorph topLeft.! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/5/2019 16:06'!testHavingADocumentAnchorAndRelativeTextAnchorPosition		anchoredMorph := Morph new.	anchoredMorph textAnchorProperties 		positionInDocument: 20 @ 10;		anchorLayout: #document.	anchorAttribute anchoredMorph: anchoredMorph.	self prepareTextMorph.		self		assert: (anchoredMorph ownerChain includes: textMorph);		 assert: anchoredMorph topLeft >= textMorph topLeft;		 assert: anchoredMorph top > textMorph top! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/5/2019 16:06'!testHavingADocumentAnchorShouldNotAffectTheLineHeight		| firstLine |	anchoredMorph := Morph new.	anchoredMorph height: 50.	anchoredMorph textAnchorProperties 		positionInDocument: 20 @ 10;		anchorLayout: #document.	anchorAttribute anchoredMorph: anchoredMorph.	self prepareTextMorph.	 	firstLine := textMorph paragraph lines first.	self			assert: (firstLine bottom - firstLine top) < 25 		description: '#document layouted anchor should not affect line height'.	! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/27/2019 18:19'!testHavingAMultilineDocumentAnchorAndRelativeTextAnchorPosition		| secondLine |	text := Text streamContents: [ :stream | 		stream			nextPutAll: 'Example with more than one line.Here is an example ';			nextPutAll: (Text				string: Character startOfHeader asString				attributes: {anchorAttribute});			nextPutAll: ' without a morph in the center.' ].	anchoredMorph := Morph new		height: 50;		yourself.	anchoredMorph textAnchorProperties 		positionInDocument: 20 @ 10;		anchorLayout: #document.	anchorAttribute anchoredMorph: anchoredMorph.	self prepareTextMorph.	secondLine := textMorph paragraph lines second.	self		assert: (anchoredMorph ownerChain includes: textMorph);		assert: anchoredMorph topLeft >= textMorph topLeft;		assert: anchoredMorph top > textMorph top;		assert: anchoredMorph top > secondLine top.! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/14/2019 20:08'!testHavingAnAnchorCanBeAlignedDifferently	| line |	anchoredMorph textAnchorProperties verticalAlignment: #(top baseline).	anchoredMorph textAnchorProperties padding. 1.	self prepareTextMorph.	line := textMorph paragraph lines first.	self assert: anchoredMorph top = (line top + line baseline).! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/27/2019 18:20'!testHavingAnAnchorInTheCenter		self 		assert: (anchoredMorph ownerChain includes: textMorph);		assert: anchoredMorph topLeft > textMorph topLeft! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/27/2019 18:20'!testHavingAnAnchorInTheCenterWithHorizontalPadding	anchoredMorph textAnchorProperties padding. 30@0.		self 		assert: (anchoredMorph ownerChain includes: textMorph);		assert: (anchoredMorph topLeft > textMorph topLeft)! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/5/2019 16:07'!testHavingAnInlineAnchorAndRelativeTextAnchorPosition		| positionWithRelativePosition positionWithoutRelativePosition |	anchoredMorph textAnchorProperties 		positionInDocument: 20@10;		anchorLayout: #inline.  	self refreshTextMorph.	positionWithRelativePosition := anchoredMorph topLeft.		anchoredMorph textAnchorProperties positionInDocument: nil.  	self refreshTextMorph.	positionWithoutRelativePosition := anchoredMorph topLeft.		self	assert: positionWithRelativePosition = positionWithoutRelativePosition! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 7/22/2019 17:45'!testLayoutingSetsTheMorphPosition		anchoredMorph := Morph new.	anchoredMorph textAnchorProperties		anchorLayout: #inline.	anchorAttribute anchoredMorph: anchoredMorph.	self prepareTextMorph.		textMorph position: 100@100.		self assert: anchoredMorph position > (100@100).! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/5/2019 11:36'!testTextAnchorWithAForm	anchorAttribute anchoredMorph: (Form dotOfSize: 60).	self prepareTextMorph.		self 		assert: textMorph paragraph lines first baseline > 20;		assert: textMorph submorphs isEmpty! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/11/2019 15:14'!testTextAnchorWithMorphDefiningItsOwnBaseline	self		after: [			anchoredMorph textAnchorProperties 				morphBaselineGetter: #myBaseline;				verticalAlignment: #(baseline baseline).			anchoredMorph height: 20]		paddingChangesTo: [:line | 			self assert: anchoredMorph top + 5 = line baseline ]! !!TextAnchorTest methodsFor: 'tests' stamp: 'pre 6/27/2019 18:19'!testTextAnchorsDoNotBreakNormalRendering		text := Text streamContents: [ :stream | 		stream			nextPutAll: 'Here is an example ';			nextPutAll: (Text				string: Character startOfHeader asString				attributes: {});			nextPutAll: ' without a morph in the center. ' ].		[self 		shouldnt: [			self prepareTextMorph.			textMorph openInWorld] 		raise: Error] ensure: [ textMorph delete ]! !!TextAnchorTest methodsFor: 'tests-padding' stamp: 'pre 6/11/2019 14:54'!testPaddingBottom	self 		after: [			anchoredMorph height: 20.			anchoredMorph textAnchorProperties verticalAlignment: #(bottom baseline).			anchoredMorph textAnchorProperties padding: (anchoredMorph textAnchorProperties padding bottom: 10)]		paddingChangesTo: [:line | 			self assert: anchoredMorph bottom + 10 = line baseline ]! !!TextAnchorTest methodsFor: 'tests-padding' stamp: 'pre 6/11/2019 14:54'!testPaddingBottomAndBottom	self 		after: [			anchoredMorph height: 20.			anchoredMorph textAnchorProperties verticalAlignment: #(bottom bottom).			anchoredMorph textAnchorProperties padding: (anchoredMorph textAnchorProperties padding bottom: 10)]		paddingChangesTo: [:line | 			self assert: anchoredMorph bottom + 10 = line bottom ]! !!TextAnchorTest methodsFor: 'tests-padding' stamp: 'pre 6/27/2019 18:27'!testPaddingBottomAndBottomWithConvenienceAlignment	self 		after: [			anchoredMorph height: 20.			anchoredMorph textAnchorProperties verticalAlignment: #bottom.			anchoredMorph textAnchorProperties padding: (anchoredMorph textAnchorProperties padding bottom: 10)]		paddingChangesTo: [:line | 			self assert: anchoredMorph bottom + 10 = line bottom ]! !!TextAnchorTest methodsFor: 'tests-padding' stamp: 'pre 6/11/2019 14:53'!testPaddingTop	self		after: [			anchoredMorph height: 20.			anchoredMorph textAnchorProperties verticalAlignment: #(top baseline).			anchoredMorph textAnchorProperties padding: (anchoredMorph textAnchorProperties padding top: 10)]		paddingChangesTo: [:line | | anchoredMorphTop | 			anchoredMorphTop := anchoredMorph top - textMorph top. 			self assert: anchoredMorphTop - 10 = line baseline ]! !!TextAnchorTest methodsFor: 'tests-padding' stamp: 'pre 6/13/2019 20:49'!testPaddingTopAndBottom		self		after: [			anchoredMorph height: 30.			anchoredMorph textAnchorProperties verticalAlignment: #(#bottom #bottom).			anchoredMorph textAnchorProperties padding: (anchoredMorph textAnchorProperties padding bottom: 10).			anchoredMorph textAnchorProperties padding: (anchoredMorph textAnchorProperties padding top: 10).]		paddingChangesTo: [:line | 			self assert: anchoredMorph bottom + 10 = line bottom.			self deny: anchoredMorph top - 10= line top description: 'We only apply padding to the morph position'.]! !!TextAnchorTest methodsFor: 'tests-padding' stamp: 'pre 6/11/2019 14:54'!testPaddingTopAndTop	self		after: [			anchoredMorph height: 20.			anchoredMorph textAnchorProperties verticalAlignment: #(top baseline).			anchoredMorph textAnchorProperties padding: (anchoredMorph textAnchorProperties padding top: 10)]		paddingChangesTo: [:line | | anchoredMorphTop | 			anchoredMorphTop := anchoredMorph top - textMorph top. 			self assert: anchoredMorphTop - 10 = line baseline ]! !!TextAnchorTestMorph methodsFor: 'text-anchor' stamp: 'pre 6/11/2019 15:09'!myBaseline	^ 5! !!TextAnchorTestMorph methodsFor: 'initialization' stamp: 'pre 6/11/2019 15:10'!initialize	super initialize.	self height: 20.! !!TextAttribute methodsFor: 'fileIn/fileOut' stamp: 'pre 6/24/2019 13:12'!writeScanOn: strm	"Implement this method for a text attribute to define how it it should be written	to a serialized form of a text object. The form should correspond to the source	file format, i.e. use a scan character to denote its subclass.	As TextAttributes are stored in RunArrays, this method is mostly called from RunArray>>#write scan.	For reading the written information see TextAttribute class>>#scanFrom:"		"Do nothing because of abstract class"! !!TextAnchor methodsFor: 'visiting' stamp: 'pre 6/5/2019 13:10'!emphasizeScanner: scanner	"Do nothing for emphasizing the scanner - if the anchor is valid, a #embeddedObject will be encountered by the scanner and do the real thing"! !!TextAnchor methodsFor: 'testing' stamp: 'pre 5/29/2019 17:18'!shoutShouldPreserve	^ true! !!TextAttribute class methodsFor: 'fileIn/Out' stamp: 'pre 6/24/2019 13:12'!scanFrom: strm	"Read the text attribute properties from the stream. When this method has	been called the concrete TextAttribute class has already been selected via	scanCharacter. (see TextAttribute class>>#newFrom:).	For writing the format see TextAttribute>>#writeScanOn:"! !!TextAnchor class methodsFor: 'examples' stamp: 'pre 6/27/2019 18:19'!alignmentExamples	"self alignmentExamples"	| anchoredMorph textMorph text demoMorph |	demoMorph := Morph new		changeTableLayout;		color: Color white;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		yourself.	#(top center bottom) do: [:morphAlignment |		#(top center baseline bottom) do: [:textAlignment |			anchoredMorph := Morph new.			anchoredMorph textAnchorProperties verticalAlignment: {morphAlignment . textAlignment}.			anchoredMorph textAnchorProperties padding: (anchoredMorph textAnchorProperties padding top: 10).			text := Text streamContents: [ :stream | 				stream					nextPutAll: ('Here is an {1}, {2} example: ' format: {morphAlignment . textAlignment});					nextPutAll: (Text						string: Character startOfHeader asString						attributes: {TextAnchor new anchoredMorph: anchoredMorph. 							TextColor color: Color transparent});					nextPutAll: ' with the morph in the text.'].			textMorph := text asMorph.			textMorph height: 100.			demoMorph addMorph: textMorph]].	demoMorph openInWorld! !!TextMorph methodsFor: 'anchors' stamp: 'pre 6/11/2019 15:47'!anchorMorph: aMorph at: aPoint type: anchorType		| relPt index newText block |	aMorph owner == self ifTrue:[self removeMorph: aMorph].	self addMorphFront: aMorph.		relPt := self transformFromWorld globalPointToLocal: aPoint.	index := (self paragraph characterBlockAtPoint: relPt) stringIndex.	newText := Text string: Character startOfHeader asString attribute: (TextAnchor new anchoredMorph: aMorph).	anchorType == #inline ifTrue:[			self paragraph replaceFrom: index to: index-1 with: newText displaying: false].	anchorType == #document ifTrue: [			index := index min: paragraph text size.			index := paragraph text string lastIndexOf: Character cr startingAt: index.			block := paragraph characterBlockForIndex: index+1.			aMorph textAnchorProperties positionInDocument: (relPt x - bounds left) @ (relPt y - block top).			self paragraph replaceFrom: index+1 to: index with: newText displaying: false].		self fit.! !!TextMorph methodsFor: 'submorphs-add/remove' stamp: 'pre 6/4/2019 17:48'!addMorphFront: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	aMorph textAnchorProperties anchorLayout == #document 		ifFalse:[^ self 					anchorMorph: aMorph 					at: wp 					type: aMorph textAnchorProperties anchorLayout].	self addMorphFront: aMorph.! !!TextMorph methodsFor: 'private' stamp: 'pre 6/11/2019 15:50'!removedMorph: aMorph	| range |	range := text find: (TextAnchor new anchoredMorph: aMorph).	range ifNotNil: [		self paragraph 			replaceFrom: range first 			to: range last			with: Text new 			displaying: false.		self fit].	super removedMorph: aMorph.! !!TextMorphForEditView class methodsFor: 'constants' stamp: 'pre 6/24/2019 13:03'!defaultTextModificationCharacterSet	"This character set includes all characters that, when entered, modify a text.	The others are control or navigation characters."		^ (ByteCharacterSet newFrom: (((0 to: 30) collect: [:code | Character value: code]) 		difference: Character separators asArray , {Character backspace})) complement! !TextAnchorTest removeSelector: #expectedFailures!TextAnchorTest removeSelector: #testHavingAnAnchorInTheMiddle!TextAnchorTest removeSelector: #testHavingAnAnchorInTheMiddleWithHorizontalPadding!TextAnchorTest removeSelector: #testPaddingTopAndTopWithConvenienceMethod!TextAnchorTest removeSelector: #testTextAnchorRemoveFromTextMorph!TestCase subclass: #TextAnchorTest	instanceVariableNames: 'anchoredMorph anchorAttribute text textMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'MorphicTests-Text Support'!!TextAnchorTest reorganize!('running' setUp)('utility' after:paddingChangesTo: prepareTextMorph refreshTextMorph)('tests' testBeginWithAnAnchor testHavingADocumentAnchorAndRelativeTextAnchorPosition testHavingADocumentAnchorShouldNotAffectTheLineHeight testHavingAMultilineDocumentAnchorAndRelativeTextAnchorPosition testHavingAnAnchorCanBeAlignedDifferently testHavingAnAnchorInTheCenter testHavingAnAnchorInTheCenterWithHorizontalPadding testHavingAnInlineAnchorAndRelativeTextAnchorPosition testLayoutingSetsTheMorphPosition testTextAnchorWithAForm testTextAnchorWithMorphDefiningItsOwnBaseline testTextAnchorsDoNotBreakNormalRendering)('tests-padding' testPaddingBottom testPaddingBottomAndBottom testPaddingBottomAndBottomWithConvenienceAlignment testPaddingTop testPaddingTopAndBottom testPaddingTopAndTop)!TextAnchorProperties removeSelector: #lineAlignmentIsMiddleString!TextAnchorProperties removeSelector: #morphAlignmentIsBaseline!TextAnchorProperties removeSelector: #morphAlignmentIsBottom!TextAnchorProperties removeSelector: #morphAlignmentIsMiddleString!TextAnchorProperties removeSelector: #verticalAlignment!!Morph reorganize!('accessing' actorState: actorStateOrNil adoptPaneColor: balloonText balloonText: balloonTextSelector balloonTextSelector: beFlap: beSticky beTransparent beUnsticky borderColor borderColor: borderStyle borderStyle: borderStyleForSymbol: borderWidth borderWidth: borderWidthForRounding clearArea color color: colorForInsets couldHaveRoundedCorners defaultNameStemForInstances eventHandler eventHandler: forwardDirection hasTranslucentColor highlight highlightColor highlightColor: insetColor isFlap isLocked isShared isSticky lock lock: methodCommentAsBalloonHelp modelOrNil player player: playerRepresented presenter raisedColor regularColor regularColor: rememberedColor rememberedColor: resistsRemoval resistsRemoval: scaleFactor setBorderStyle: sqkPage sticky: toggleLocked toggleResistsRemoval toggleStickiness unHighlight unlock unlockContents url userString viewBox visibleClearArea wantsToBeCachedByHand wantsToBeTopmost)('accessing - extension' assureExtension extension hasExtension initializeExtension privateExtension: resetExtension)('accessing - properties' hasProperty: otherProperties removeProperty: setProperties: setProperty:toValue: valueOfProperty: valueOfProperty:ifAbsent: valueOfProperty:ifAbsentPut: valueOfProperty:ifPresentDo:)('caching' fullLoadCachedState fullReleaseCachedState loadCachedState releaseCachedState)('change reporting' colorChangedForSubmorph: invalidRect: invalidRect:from: ownerChanged privateInvalidateMorph: userSelectedColor:)('classification' demandsBoolean isAlignmentMorph isBalloonHelp isCompoundTileMorph isFlapOrTab isFlapTab isFlexMorph isHandMorph isKedamaMorph isModalShell isNumericReadoutTile isPhraseTileMorph isPlayfieldLike isRenderer isSoundTile isStandardViewer isStickySketchMorph isSyntaxMorph isTextMorph isTileMorph isTilePadMorph isViewer isWorldMorph isWorldOrHandMorph)('connectors-scripting' wantsConnectorVocabulary)('converting' asDraggableMorph asSnapshotThumbnail)('copying' copy deepCopy duplicate duplicateMorphCollection: fullCopy updateReferencesUsing: usableSiblingInstance veryDeepCopyWith: veryDeepFixupWith: veryDeepInner:)('creation' asMorph)('debug and other' addDebuggingItemsTo:hand: addMouseActionIndicatorsWidth:color: addMouseUpAction addMouseUpActionWith: addViewingItemsTo: allStringsAfter: altSpecialCursor0 altSpecialCursor1 altSpecialCursor2 altSpecialCursor3 altSpecialCursor3: buildDebugMenu: defineTempCommand deleteAnyMouseActionIndicators inspectArgumentsPlayerInMorphic: inspectOwnerChain installModelIn: mouseUpCodeOrNil ownerChain programmedMouseDown:for: programmedMouseEnter:for: programmedMouseLeave:for: programmedMouseUp:for: removeMouseUpAction resumeAfterDrawError resumeAfterStepError tempCommand viewMorphDirectly)('dispatching' disableSubmorphFocusForHand:)('drawing' areasRemainingToFill: boundingBoxOfSubmorphs boundsWithinCorners changeClipSubmorphs clipLayoutCells clipLayoutCells: clipSubmorphs clipSubmorphs: clippingBounds doesOwnRotation drawDropHighlightOn: drawDropShadowOn: drawErrorOn: drawKeyboardFocusIndicationOn: drawMouseDownHighlightOn: drawOn: drawOverlayOn: drawRolloverBorderOn: drawSubmorphsOn: expandFullBoundsForDropShadow: expandFullBoundsForRolloverBorder: flashBounds fullDrawOn: hasClipSubmorphsString hide highlightForMouseDown highlightForMouseDown: highlightedForMouseDown imageForm imageForm:backgroundColor:forRectangle: imageForm:forRectangle: imageFormDepth: imageFormForRectangle: imageFormWithout:andStopThere: keyboardFocusColor keyboardFocusWidth refreshWorld shadowForm show updateDropShadowCache visible visible:)('drop shadows' addDropShadow addDropShadowMenuItems:hand: changeShadowColor hasDropShadow hasDropShadow: hasDropShadowString hasRolloverBorder hasRolloverBorder: removeDropShadow setShadowOffset: shadowColor shadowColor: shadowOffset shadowOffset: shadowPoint: toggleDropShadow useSoftDropShadow useSoftDropShadow:)('dropping/grabbing' aboutToBeGrabbedBy: acceptDroppingMorph:event: disableDragNDrop dragEnabled dragEnabled: dragNDropEnabled dragSelectionColor dropEnabled dropEnabled: dropHighlightColor dropSuccessColor enableDrag: enableDragNDrop enableDragNDrop: enableDrop: formerOwner formerOwner: formerPosition formerPosition: grabTransform handledOwnDraggingBy:on: highlightForDrop highlightForDrop: highlightedForDrop justDroppedInto:event: justGrabbedFrom: morphToDropInPasteUp: nameForUndoWording rejectDropMorphEvent: repelsMorph:event: resetHighlightForDrop separateDragAndDrop slideBackToFormerSituation: slideToTrash: startDrag:with: transportedMorph undoGrabCommand vanishAfterSlidingTo:event: wantsDroppedMorph:event: wantsToBeDroppedInto: wantsToBeOpenedInWorld willingToBeDiscarded)('event handling' click click: cursorPoint doubleClick: doubleClickTimeout: dropFiles: firstClickTimedOut: handlerForMouseDown: handlerForYellowButtonDown: handlesKeyboard: handlesMouseDown: handlesMouseMove: handlesMouseOver: handlesMouseOverDragging: handlesMouseStillDown: handlesMouseWheel: hasFocus hasKeyboardFocus hasKeyboardFocus: hasMouseFocus hasMouseFocus: keyDown: keyStroke: keyUp: keyboardFocusChange: keyboardFocusDelegate mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseStillDown: mouseStillDownThreshold mouseUp: mouseWheel: moveOrResizeFromKeystroke: on:send:to: on:send:to:withValue: preferredKeyboardBounds preferredKeyboardPosition removeLink: restoreSuspendedEventHandler startDrag: suspendEventHandler tabAmongFields transformFrom: transformFromOutermostWorld transformFromWorld wantsDropFiles: wantsEveryMouseMove wantsKeyboardFocus wantsKeyboardFocusFor: wantsWindowEvents: windowEvent: wouldAcceptKeyboardFocus wouldAcceptKeyboardFocusUponTab yellowButtonActivity:)('events-accessing' actionMap updateableActionMap)('events-alarms' addAlarm:after: addAlarm:at: addAlarm:with:after: addAlarm:with:at: addAlarm:with:with:after: addAlarm:with:with:at: addAlarm:withArguments:after: addAlarm:withArguments:at: alarmScheduler removeAlarm: removeAlarm:at:)('events-processing' containsPoint:event: defaultEventDispatcher handleDropFiles: handleDropMorph: handleEvent: handleFocusEvent: handleKeyDown: handleKeyUp: handleKeystroke: handleListenEvent: handleMouseDown: handleMouseEnter: handleMouseLeave: handleMouseMove: handleMouseOver: handleMouseStillDown: handleMouseUp: handleMouseWheel: handleUnknownEvent: handleWindowEvent: mouseDownPriority mouseDownPriority: processEvent: processEvent:using: processFocusEvent: processFocusEvent:using: rejectDropEvent: rejectsEvent: sendFilterEvent:for:to: sendFilterEventBubble:for: sendFilterEventBubbleAgain:for: sendFilterEventCapture:for: sendFilterEventCaptureAgain:for: transformedFrom:)('events-removing' releaseActionMap)('fileIn/out' attachToResource reserveUrl: saveAsResource saveDocPane saveOnFile saveOnURL saveOnURL: saveOnURLbasic updateAllFromResources updateFromResource)('filter streaming' drawOnCanvas:)('geometry' align:with: bottom bottom: bottomCenter bottomLeft bottomLeft: bottomRight bottomRight: bounds bounds: bounds:from: bounds:in: boundsIn: boundsInWorld center center: extent fullBoundsInWorld globalPointToLocal: gridPoint: griddedPoint: height height: innerBounds intersects: left left: leftCenter localPointToGlobal: minimumExtent minimumExtent: minimumHeight minimumHeight: minimumWidth minimumWidth: outerBounds overlapsShadowForm:bounds: point:from: point:in: pointFromWorld: pointInWorld: position position: positionInWorld positionSubmorphs right right: rightCenter screenLocation screenRectangle setConstrainedPosition:hangOut: shiftSubmorphsOtherThan:by: top top: topCenter topLeft topLeft: topRight topRight: transformedBy: width width: worldBounds worldBoundsForHalo)('geometry testing' containsPoint: fullContainsPoint: obtrudesBeyondContainer)('halos and balloon help' addHalo addHalo:from: addHandlesTo:box: addMagicHaloFor: addOptionalHandlesTo:box: addSimpleHandlesTo:box: addWorldHandlesTo:box: balloonColor balloonColor: balloonFont balloonFont: balloonHelpAligner balloonHelpDelayTime balloonHelpTextForHandle: balloonMorphClass boundsForBalloon comeToFrontAndAddHalo createHalo defaultBalloonColor defaultBalloonFont defersHaloOnClickTo: deleteBalloon editBalloonHelpContent: editBalloonHelpText halo haloClass haloDelayTime hasHalo hasHalo: isLikelyRecipientForMouseOverHalos mouseDownOnHelpHandle: noHelpString okayToAddDismissHandle okayToAddGrabHandle okayToBrownDragEasily okayToExtractEasily okayToResizeEasily okayToRotateEasily preferredDuplicationHandleSelector removeHalo setBalloonText: setBalloonText:maxLineLength: setCenteredBalloonText: showBalloon showBalloon: showBalloon:at: showBalloon:hand: transferHalo:from: wantsBalloon wantsDirectionHandles wantsDirectionHandles: wantsHalo wantsHaloFor: wantsHaloFromClick wantsHaloFromClick: wantsHaloHandleWithSelector:inHalo: wantsScriptorHaloHandle wantsSimpleSketchMorphHandles)('initialization' basicInitialize defaultBounds defaultColor inAScrollPane inATwoWayScrollPane initialize intoWorld: openCenteredInWorld openInWindow openInWindowLabeled: openInWindowLabeled:inWorld: openInWorld openNear: openNear:in: openNearMorph: outOfWorld: resourceJustLoaded standardPalette)('layout' adjustLayoutBounds doLayoutIn: fullBounds layoutBounds layoutBounds: layoutChanged layoutInBounds: layoutProportionallyIn: minExtent minExtent: minHeight minHeight: minWidth minWidth: privateFullBounds submorphBounds)('layout-menu' addCellLayoutMenuItems:hand: addLayoutMenuItems:hand: addTableLayoutMenuItems:hand: changeCellInset: changeClipLayoutCells changeDisableTableLayout changeLayoutInset: changeListDirection: changeMaxCellSize: changeMinCellSize: changeNoLayout changeProportionalLayout changeReverseCells changeRubberBandCells changeTableLayout hasClipLayoutCellsString hasDisableTableLayoutString hasNoLayoutString hasProportionalLayoutString hasReverseCellsString hasRubberBandCellsString hasTableLayoutString layoutMenuPropertyString:from:)('layout-properties' assureLayoutProperties assureTableProperties cellInset cellInset: cellPositioning cellPositioning: cellPositioningString: cellSpacing cellSpacing: cellSpacingString: copyLayoutProperties disableTableLayout disableTableLayout: hResizing hResizing: hResizingString: layoutFrame layoutFrame: layoutInset layoutInset: layoutPolicy layoutPolicy: layoutProperties layoutProperties: listCentering listCentering: listCenteringString: listDirection listDirection: listDirectionString: listSpacing listSpacing: listSpacingString: maxCellSize maxCellSize: minCellSize minCellSize: reverseTableCells reverseTableCells: rubberBandCells rubberBandCells: spaceFillWeight spaceFillWeight: vResizeToFit: vResizing vResizing: vResizingString: wrapCentering wrapCentering: wrapCenteringString: wrapDirection wrapDirection: wrapDirectionString:)('macpal' flash)('menu' addBorderStyleMenuItems:hand: addGestureMenuItems:hand: addGraphModelYellowButtonItemsTo:event: addModelYellowButtonItemsTo:event: addMyYellowButtonMenuItemsToSubmorphMenus addNestedYellowButtonItemsTo:event: addTitleForHaloMenu: addYellowButtonMenuItemsTo:event: buildYellowButtonMenu: hasYellowButtonMenu offerCostumeViewerMenu: outermostOwnerWithYellowButtonMenu startWiring wantsMetaMenu wantsMetaMenu: wantsYellowButtonMenu wantsYellowButtonMenu:)('menus' absorbStateFromRenderer: addAddHandMenuItemsForHalo:hand: addCopyItemsTo: addCustomHaloMenuItems:hand: addCustomMenuItems:hand: addExportMenuItems:hand: addFillStyleMenuItems:hand: addHaloActionsTo: addMiscExtrasTo: addPaintingItemsTo:hand: addStandardHaloMenuItemsTo:hand: addToggleItemsToHaloMenu: addWorldTargetSightingItems:hand: adhereToEdge adhereToEdge: adjustedCenter adjustedCenter: allMenuWordings changeColor changeDirectionHandles changeDrag changeDragAndDrop changeDrop chooseNewGraphic chooseNewGraphicCoexisting: chooseNewGraphicFromHalo collapse defaultArrowheadSize doMenuItem: exploreInMorphic exploreInMorphic: exportAsBMP exportAsBMPNamed: exportAsGIF exportAsGIFNamed: exportAsJPEG exportAsJPEGNamed: exportAsPNG exportAsPNGNamed: hasDirectionHandlesString hasDragAndDropEnabledString hasDragEnabledString hasDropEnabledString helpButton inspectInMorphic inspectInMorphic: lockUnlockMorph lockedString makeNascentScript maybeAddCollapseItemTo: menuItemAfter: menuItemBefore: model presentHelp reasonableBitmapFillForms reasonableForms resetForwardDirection resistsRemovalString setArrowheads setRotationCenter setRotationCenterFrom: setToAdhereToEdge: snapToEdgeIfAppropriate stickinessString transferStateToRenderer: uncollapseSketch)('meta-actions' addEmbeddingMenuItemsTo:hand: applyStatusToAllSiblings: beThisWorldsModel bringAllSiblingsToMe: buildHandleMenu: buildMetaMenu: changeColorTarget:selector:originalColor:hand: copyToPasteBuffer: dismissMorph dismissMorph: duplicateMorph: duplicateMorphImage: embedInto: grabMorph: indicateAllSiblings inspectAt:event: invokeHaloOrMove: invokeMetaMenu: invokeMetaMenuAt:event: makeMultipleSiblings: makeNewPlayerInstance: makeSiblings: makeSiblingsLookLikeMe: maybeDuplicateMorph maybeDuplicateMorph: openAPropertySheet openATextPropertySheet potentialEmbeddingTargets potentialTargets potentialTargetsAt: resizeFromMenu resizeMorph: saveAsPrototype showActions showHiders sightTargets: sightWorldTargets: subclassMorph targetFromMenu: targetWith:)('miscellaneous' roundUpStrays setExtentFromHalo: setFlexExtentFromHalo:)('naming' downshiftedNameOfObjectRepresented innocuousName name: nameForFindWindowFeature nameInModel nameOfObjectRepresented setNamePropertyTo: setNameTo: specialNameInModel tryToRenameTo: updateAllScriptingElements)('objects from disk' objectForDataStream: storeDataOn:)('other events' menuButtonMouseEnter: menuButtonMouseLeave:)('parts bin' inPartsBin initializeToStandAlone isPartsBin isPartsDonor isPartsDonor: markAsPartsDonor partRepresented residesInPartsBin)('printing' clipText colorString: constructorString fullPrintOn: initString morphReport morphReportFor: morphReportFor:on:indent: pagesHandledAutomatically printConstructorOn:indent: printConstructorOn:indent:nodeDict: printOn: printSpecs printSpecs: printStructureOn:indent: reportableSize structureString textToPaste)('*FlatWorld-Core')('rotate scale and flex' addFlexShell addFlexShellIfNecessary keepsTransform newTransformationMorph referencePosition referencePosition: referencePositionInWorld referencePositionInWorld: removeFlexShell rotationCenter rotationCenter: rotationDegrees)('rounding' cornerRadius cornerRadius: cornerStyle cornerStyle: roundedCorners roundedCornersString toggleCornerRounding wantsRoundedCorners)('stepping and presenter' arrangeToStartStepping arrangeToStartSteppingIn: isStepping isSteppingSelector: start startStepping startStepping:at:arguments:stepTime: startSteppingIn: startSteppingSelector: step stepAt: stepTime stop stopStepping stopSteppingSelector: stopSteppingSelfAndSubmorphs wantsSteps)('structure' activeHand allOwners allOwnersDo: containingWindow firstOwnerSuchThat: hasOwner: isInDockingBar isInSystemWindow isInWorld morphPreceding: nearestOwnerThat: orOwnerSuchThat: outermostMorphThat: outermostWorldMorph owner ownerThatIsA: ownerThatIsA:orA: pasteUpMorph pasteUpMorphHandlingTabAmongFields primaryHand renderedMorph root rootAt: topPasteUp topRendererOrSelf withAllOwners withAllOwnersDo: world)('submorphs-accessing' allKnownNames allMorphs allMorphsDo: allNonSubmorphMorphs allSubmorphNamesDo: dockingBars findA: findDeepSubmorphThat:ifAbsent: findDeeplyA: findSubmorphBinary: firstSubmorph hasSubmorphWithProperty: hasSubmorphs indexOfMorphAbove: lastSubmorph mainDockingBars morphsAt: morphsAt:behind:unlocked: morphsAt:unlocked: morphsAt:unlocked:do: morphsInFrontOf:overlapping:do: morphsInFrontOverlapping: morphsInFrontOverlapping:do: noteNewOwner: rootMorphsAt: rootMorphsAtGlobal: shuffleSubmorphs submorphAfter submorphBefore submorphCount submorphNamed: submorphNamed:ifNone: submorphOfClass: submorphThat:ifNone: submorphWithProperty: submorphs submorphsBehind:do: submorphsDo: submorphsInFrontOf:do: submorphsReverseDo: submorphsSatisfying:)('submorphs-add/remove' abandon actWhen actWhen: addAllMorphs: addAllMorphs:after: addAllMorphs:behind: addAllMorphs:inFrontOf: addAllMorphsBack: addAllMorphsFront: addMorph: addMorph:after: addMorph:asElementNumber: addMorph:behind: addMorph:fullFrame: addMorph:inFrontOf: addMorphBack: addMorphCentered: addMorphFront: addMorphFront:fromWorldPosition: addMorphFrontFromWorldPosition: addMorphNearBack: allMorphsWithPlayersDo: comeToFront copyWithoutSubmorph: delete deleteDockingBars deleteSubmorphsWithProperty: deleteUnlessHasFocus dismissViaHalo goBehind privateDelete removeAllMorphs removeAllMorphsIn: removeMorph: removedMorph: replaceSubmorph:by: submorphIndexOf:)('testing' canDrawAtHigherResolution canDrawBorder: completeModificationHash couldMakeSibling indicateKeyboardFocus isDockingBar isFlexed isFullOnScreen isImageMorph isLineMorph isMenuItemMorph isMorph isSafeToServe isSelectionMorph isSketchMorph knownName modificationHash renameInternal: renameTo: shouldDropOnMouseUp)('text-anchor' addTextAnchorMenuItems:hand: textAnchorProperties)('thumbnail' demandsThumbnailing icon iconOrThumbnail iconOrThumbnailOfSize: morphRepresented permitsThumbnailing readoutForField: representativeNoTallerThan:norWiderThan:thumbnailHeight: thumbnail updateThumbnailUrl updateThumbnailUrlInBook:)('undo' commandHistory undoMove:redo:owner:bounds:predecessor:)('updating' applyUserInterfaceTheme changed)('user interface' defaultLabelForInspector doCancel initialExtent)('viewer' externalName)('visual properties' canApplyUserInterfaceTheme canHaveFillStyles defaultBitmapFillForm fillStyle fillStyle: fillWithRamp:oriented: useBitmapFill useDefaultFill useGradientFill useSolidFill)('WiW support' addMorphInFrontOfLayer: addMorphInLayer: eToyRejectDropMorph:event: morphicLayerNumber morphicLayerNumberWithin: randomBoundsFor: shouldGetStepsFrom:)('*MorphicExtras-accessing')('*MorphicExtras-geometry' shiftSubmorphsBy:)('*MorphicExtras-menus' dismissButton printPSToFileNamed:)('*services-base' requestor)('private' canBeEncroached privateAddAllMorphs:atIndex: privateAddMorph:atIndex: privateBounds: privateColor: privateDeleteWithAbsolutelyNoSideEffects privateFullBounds: privateFullMoveBy: privateOwner: privateRemove: privateRemoveMorphWithAbsolutelyNoSideEffects: privateSubmorphs privateSubmorphs:)('accessing-backstop' target:)('e-toy support' adaptToWorld: allMorphsAndBookPagesInto: asNumber: automaticViewing currentPlayerDo: cursor cursor: decimalPlacesForGetter: defaultValueOrNil embedInWindow embeddedInMorphicWindowLabeled: getNumericValue gridFormOrigin:grid:background:line: handUserASibling isAViewer isTileEditor makeGraphPaper makeGraphPaperGrid:background:line: mustBeBackmost noteDecimalPlaces:forGetter: objectViewed referencePlayfield rotationStyle rotationStyle: setAsActionInButtonProperties: setNumericValue: setStandardTexture textureParameters unlockOneSubpart updateCachedThumbnail wantsRecolorHandle wrappedInWindow: wrappedInWindowWithTitle:)('geniestubs' allowsGestureStart: isGestureStart: mouseStillDownStepRate redButtonGestureDictionaryOrName: yellowButtonGestureDictionaryOrName:)('*morphic-Postscript Canvases' asPostscript fullDrawPostscriptOn: printPSToFile)('player' assureExternalName okayToDuplicate shouldRememberCostumes)('player commands' playSoundNamed:)('button' doButtonAction)('model access' models)('player viewer' openViewerForArgument)('other' removeAllButFirstSubmorph)('selected object' selectedObject)('polymorph' modalLockTo: modalUnlockFrom: openModal:)('*Etoys-card in a stack' abstractAModel addStackItemsTo: assuredCardPlayer beAStackBackground becomeSharedBackgroundField containsCard: couldHoldSeparateDataForEachInstance currentDataInstance currentDataValue explainDesignations goToNextCardInStack goToPreviousCardInStack holdsSeparateDataForEachInstance insertAsStackBackground insertCard installAsCurrent: isStackBackground makeHoldSeparateDataForEachInstance newCard reassessBackgroundShape relaxGripOnVariableNames reshapeBackground setAsDefaultValueForNewCard showBackgroundObjects showDesignationsOfObjects showForegroundObjects stack stackDo: stopHoldingSeparateDataForEachInstance tabHitWithEvent: variableDocks wrapWithAStack)('*Etoys' accumlatePlayersInto:andSelectorsInto: actorState addPlayerItemsTo: assuredPlayer boundsSignatureHash categoriesForViewer choosePenColor: choosePenSize currentVocabulary ensuredButtonProperties forward: getPenColor getPenDown getPenSize isPlayer:ofReferencingTile: isTurtleRow liftPen lowerPen moveWithPenDownBy: newPlayerInstance penColor: penUpWhile: putOnBackground putOnForeground scriptPerformer selectorsForViewer selectorsForViewerIn: showPlayerMenu trailMorph traverseRowTranslateSlotOld:of:to: traverseRowTranslateSlotOld:to: turn: understandsBorderVocabulary unfilteredCategoriesForViewer)('*Etoys-support' adoptVocabulary: affiliatedSelector appearsToBeSameCostumeAs: asWearableCostume asWearableCostumeOfExtent: beep: buttonProperties buttonProperties: changeAllBorderColorsFrom:to: configureForKids copyCostumeStateFrom: creationStamp defaultVariableName definePath deletePath enclosingEditor enforceTileColorPolicy fenceEnabled fire firedMouseUpCode followPath getCharacters handMeTilesToFire hasButtonProperties isCandidateForAutomaticViewing jumpTo: listViewLineForFieldList: makeFenceSound noteNegotiatedName:for: pinkXButton restoreBaseGraphic set: slotSpecifications succeededInRevealing: tanOButton topEditor updateLiteralLabel)('*Etoys-scripting' arrowDeltaFor: asEmptyPermanentScriptor bringTileScriptingElementsUpToDate bringUpToDate defaultFloatPrecisionFor: filterViewerCategoryDictionary: isTileLike isTileScriptingElement jettisonScripts makeAllTilesColored makeAllTilesGreen restoreTypeColor scriptEditorFor: tearOffTile triggerScript: useUniformTileColor viewAfreshIn:showingScript:at: wantsConnectionVocabulary)('*Etoys-customevents-scripting' instantiatedUserScriptsDo: removeAllEventTriggers removeAllEventTriggersFor: removeEventTrigger: removeEventTrigger:for: renameScriptActionsFor:from:to: triggerCustomEvent: triggerEtoyEvent: triggerEtoyEvent:from:)('*Rack-UI' openRackStandardMorph worldIconMorph worldIconText)('*Etoys-geometry' addTransparentSpacerOfSize: cartesianBoundsTopLeft cartesianXY: color:sees: colorUnder degreesOfFlex forwardDirection: getIndexInOwner goHome heading heading: move:toPosition: scale: scaleFactor: setDirectionFrom: setIndexInOwner: simplySetVisible: touchesColor: transparentSpacerOfSize: wrap x x: x:y: y y:)('*Etoys-latter day support' isEtoyReadout)('*MorphicExtras-svg' clipPostscript drawPostscriptOn:)('*MorphicExtras-postscript' asEPS asPostscriptPrintJob exportAsEPS exportAsEPSNamed:)('*Morphic-Sound-piano rolls' addMorphsTo:pianoRoll:eventTime:betweenTime:and: encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: justDroppedIntoPianoRoll:event: pauseFrom: resetFrom: resumeFrom: triggerActionFromPianoRoll)('*MorphicExtras' nextOwnerPage previousOwnerPage)('events-filtering-bubbling' addEventBubbleFilter: addKeyboardBubbleFilter: addMouseBubbleFilter: eventBubbleFilters eventBubbleFilters: keyboardBubbleFilters keyboardBubbleFilters: mouseBubbleFilters mouseBubbleFilters: removeEventBubbleFilter: removeKeyboardBubbleFilter: removeMouseBubbleFilter:)('events-filtering-capturing' addEventCaptureFilter: addKeyboardCaptureFilter: addMouseCaptureFilter: eventCaptureFilters eventCaptureFilters: keyboardCaptureFilters keyboardCaptureFilters: mouseCaptureFilters mouseCaptureFilters: removeEventCaptureFilter: removeKeyboardCaptureFilter: removeMouseCaptureFilter:)('events-filtering' addFilter:to: eventFilterDocumentation removeFilter:from:)('*AtomicPlants')('*signals-morphic' emitInOwnerChain emitSignalInOwnerChain:arguments:sender: sgConnectSignal:to:selector: sgConnectSignal:to:selector:pattern: sgConnectSignal:toSelector: sgConnectSignal:toSelector:pattern: sgDisconnectSignal:from:selector: sgDisconnectSignal:fromSelector: signalConnectionsForOwnerChain)('*animations-core' animations fullDrawAnimatedOn: hasAnimationRunning ignoresColorMappings ignoresColorMappings: redraw redrawLater transformedCanvasFrom:)('*animations-examples' darken fadeIn fadeInThen: fadeOut fadeOutThen: lighten pulse walkToPosition: warpToPosition:)('*animations-support' compositeAnimations darkenAnimation)('*widgets-signals-processing' disconnectAllSignals hasSignalConnections signalConnections signalMutex)('*widgets-events' enabled enabled: grabKeyboard grabMouse keyboardFocusChange:inSubmorph: releaseKeyboard releaseMouse)('*widgets-geometry-override' extent: privateMoveBy:)('*widgets-signals' extentChanged: positionChanged:)('*widgets' frameFractions frameFractions: frameOffsets frameOffsets: fullDrawCacheOn: hideFull isTransformMorph isUiContainer showFull)('*widgets-events-testing' hasAnyKeyboard hasKeyboard hasMouse hasSubmorphKeyboard)('*widgets-geometry' visibleBounds)('*vivide-layout')('*vivide')('*vivide-morphic')('*skeleton-base-arrow' addHalo:)('*skeleton-base-sheet')('*Pheno-Styles' addStyleClass: addStyleClasses: addedMorph: assureWidgetParent convertPaddingToRectangle: isWidget prepareToBeSaved removeStyleClass: resetStyleState styleClasses styleContext update: updateHierarchyStyleState updateStyleProperties updateStylePropertiesReal useCustomTheme: useGlobalTheme)('*Etoys-Squeakland-halo notification' aboutToBeBrownDragged aboutToBeGrownViaHalo aboutToBeRotatedViaHalo aboutToBeScaledViaHalo brownDragConcluded growConcluded rotationConcluded scaleConcluded)('*Etoys-Squeakland-menu & halo' addLockingItemsTo: menuButton offerMenu)('*Etoys-Squeakland-WiW support' addMorphInLayer:centeredNear:)('*Etoys-Squeakland-geometry' boundsInStagingArea collapsible spanContainerVertically: stagingArea)('*Etoys-Squeakland-Etoys-SpeechBubbles' bubble bubble: say: sayGraphic: sayObject: showGraphic:inBubbleType: showMessage:inBubbleType: showObject:inBubbleType: stopSayingOrThinking think: thinkGraphic: thinkObject:)('*Etoys-Squeakland-meta-actions' changeColorSimply changeColorTarget:selector:originalColor:hand:showPalette: embedEnabled openAppropriatePropertySheet showEmbedMenu targetFromMenu:popupAt:)('*Etoys-Squeakland-visual properties' changeGraphPaper useGraphPaperFill)('*Etoys-Squeakland-e-toy support' chosenColor: enclosingTestTile fixLayoutOfSubmorphs hideWillingnessToAcceptDropFeedback outmostScriptEditor putUpGraphPaperPanel removeViewersOnSubsIn: showWillingnessToAcceptDropFeedback unembedSubmorphsInWindow)('*Etoys-Squeakland-accessing - extension' convertExtension)('*Etoys-Squeakland-object fileIn' convertNovember2000DropShadow:using:)('*Etoys-Squeakland-accessing' deepSubpartNamed: eventRoll)('*Etoys-Squeakland-classification' defersHaloToInterior defersHaloToInteriorMorph: fontsForText)('*Etoys-Squeakland-misc' doesColorAndBorder)('*Etoys-Squeakland-display' editMenuButtonDefinition)('*Etoys-Squeakland-latter day support' encouragesHaloTransferToEnclosedPasteUpMorph)('*Etoys-Squeakland-viewing' establishGraphPaperFrom:)('*Etoys-Squeakland-miscellaneous' finalTilePadSubmorph)('*Etoys-Squeakland-other' fixUpCarets)('*Etoys-Squeakland-debug and other' inspectMorphsProperties)('*Etoys-Squeakland-layout' justAddedAsTileRow)('*Etoys-Squeakland-drop outside' mimeTypes)('*Etoys-Squeakland-initialization' naviHeight: openInWorldOrWorldlet openNearTopLeftOfScreen)('*Etoys-Squeakland-submorphs-accessing' ownerSatisfying:)('*Etoys-Squeakland-event roll' putEventsOnto: suitableForDroppingIntoEventRoll)('*Etoys-Squeakland-structure' referenceWorld referenceWorldViaOwnwer)('*Etoys-Squeakland-dropping/grabbing' repelEnabledForMorph:)('*Etoys-Squeakland-geometry eToy' rotationDegrees:)('*Etoys-Squeakland-fileIn/out' saveOnFile:)('*Etoys-Squeakland-translation' traverseSearchForKedamaTurtleIfFound:)('*Etoys-Squeakland-testing' isButton wantsGraphPaperAlternative)('*Etoys-Squeakland-halos and balloon help')('*60Deprecated-user-interface' becomeModal)('*ToolBuilder-Morphic-opening' buildWith: openAsTool)('*53Deprecated-dropping/grabbing')('*60Deprecated-meta-actions' blueButtonDown: blueButtonUp: handlerForBlueButtonDown: handlerForMetaMenu:)('*60Deprecated-accessing' doesBevels)('*60Deprecated-text-anchor' changeDocumentAnchor changeInlineAnchor changeParagraphAnchor hasDocumentAnchorString hasInlineAnchorString hasParagraphAnchorString relativeTextAnchorPosition relativeTextAnchorPosition: textAnchorType textAnchorType:)('*60Deprecated-MorphicExtras-accessing' highlightOnlySubmorph:)('*GM-Keys')('*GM-Collision')('*Squot-trackable' squotInitializeStoreInfo:)('*GameMecha-Collisions')('*GameMecha-Keys')('*GM-Core')('*animations-control' deleteAnimations pauseAnimations resumeAnimations stopAnimations)('*StarTrack-Client' openInHand openInWorld:)('*60Deprecated-dropping/grabbing' toggleDragNDrop)('*BabylonianProgramming-UI' isBPAnnotationMorph)!BitBltDisplayScanner removeSelector: #displayEmbeddedForm:!DisplayScanner removeSelector: #displayEmbeddedForm:!DisplayScanner removeSelector: #placeEmbeddedObject:!DisplayScanner removeSelector: #placeEmbeddedObjectRelative:!DisplayScanner removeSelector: #verticallyAlignEmbeddedMorph:given:!DisplayScanner removeSelector: #verticallyAlignEmbeddedObject:given:and:!CompositionScanner removeSelector: #alignmentMorphOffsetFor:!CompositionScanner removeSelector: #baselineAdjustmentForMorph:!CompositionScanner removeSelector: #lineHeightForMorphOfHeight:aligned:to:paddedWith:!CompositionScanner removeSelector: #placeEmbeddedObject:!CharacterBlockScanner removeSelector: #placeEmbeddedObject:!CharacterScanner subclass: #CharacterBlockScanner	instanceVariableNames: 'characterPoint characterIndex nextLeftMargin lastCharacterWidth'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Text'!CharacterScanner removeSelector: #placeEmbeddedObject:!!CharacterScanner reorganize!('initialize' initialize)('scanner methods' handleEndOfRunAt:)('scanning' basicScanByteCharactersFrom:to:in:rightX: measureString:inFont:from:to: primScanCharactersFrom:to:in:rightX:stopConditions:kern: scanByteCharactersFrom:to:in:rightX: scanCharactersFrom:to:in:rightX: scanCharactersFrom:to:in:rightX:stopConditions:kern: scanKernableByteCharactersFrom:to:in:rightX:)('private-text-anchor' textAnchorPropertiesFor:)('private' advanceIfFirstCharOfLine handleIndentation indentationLevel leadingTab placeEmbeddedObjectFrom: plainTab setFont setStopConditions text:textStyle:)('*ST80-Support' initializeFromParagraph:clippedBy:)('text attributes' addEmphasis: addKern: indentationLevel: setActualFont: setAlignment: setFont: textColor:)('stop conditions' columnBreak embeddedObject)('*45Deprecated' initializeStringMeasurer)('*Multilingual-Display' isBreakableAt:in:in: registerBreakableIndex scanJapaneseCharactersFrom:to:in:rightX: scanKernableMultibyteCharactersFrom:to:in:rightX: scanMultibyteCharactersFrom:to:in:rightX:)!